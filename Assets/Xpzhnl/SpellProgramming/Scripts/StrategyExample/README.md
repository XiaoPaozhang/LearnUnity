# 策略模式示例 - 快速导航

## 🎯 这是什么？

这是一套**完整的示例代码**，展示如何用策略模式重构法术系统，解决 `SpellStats` 臃肿的问题。

**重要：这些代码不会影响你现有的系统！**

---

## 📚 阅读顺序

### 第1步：理解问题

👉 **打开：`00_策略模式说明.md`**

- 了解要解决什么问题
- 看架构对比图
- 5分钟阅读

### 第2步：属性拆分

👉 **打开：`01_拆分后的属性.cs`**

- 看 `SpellStats` 如何拆分
- 理解为什么要拆分
- 对比现有的 `Step2_SpellStats.cs`

### 第3步：策略接口

👉 **打开：`02_策略接口.cs`**

- 理解策略模式的接口
- 看为什么用 `ScriptableObject`

### 第4步：具体实现

👉 **打开：`03_具体策略实现.cs`**

- 看投射物、修饰符、触发器的策略
- 对比现有的 `Step4_SpellData.cs`

### 第5步：新的数据结构

👉 **打开：`04_新的SpellData.cs`**

- 看重构后的 `SpellDataV2`
- 理解如何使用策略

### 第6步：使用示例

👉 **打开：`05_使用示例.cs`**

- 看实际使用代码
- 理解如何调用

### 第7步：迁移决策

👉 **打开：`06_迁移指南.md`**

- 决定是否要迁移
- 选择迁移方案

---

## 🎨 可视化对比

### 现有系统

```
┌─────────────────────────────┐
│     Step4_SpellData.cs      │
│                             │
│  SpellStats (巨大)          │
│  ├─ damage                  │
│  ├─ speed                   │
│  ├─ damageMultiplier        │
│  ├─ triggerDelay            │
│  └─ ... 40+ 字段            │
│                             │
│  Execute() {                │
│    switch(type) {           │
│      case Projectile: ...   │
│      case Modifier: ...     │
│      case Trigger: ...      │
│    }                        │
│  }                          │
└─────────────────────────────┘
```

### 策略模式系统

```
┌──────────────────────────────────────┐
│        SpellDataV2.cs                │
│                                      │
│  BaseSpellStats         (所有法术)  │
│  ProjectileSpellStats   (投射物专属)│
│  ModifierSpellStats     (修饰符专属)│
│  TriggerSpellStats      (触发器专属)│
│                                      │
│  ISpellBehavior behavior             │
│                                      │
│  Execute() {                         │
│    behavior.Execute(this);           │
│  }                                   │
└──────────────────────────────────────┘
         │
         ├──────────┬──────────┬──────────┐
         ▼          ▼          ▼          ▼
    ┌─────────┐┌─────────┐┌─────────┐┌─────────┐
    │Projectile││Modifier││Trigger  ││Utility  │
    │Behavior ││Behavior││Behavior ││Behavior │
    └─────────┘└─────────┘└─────────┘└─────────┘
```

---

## 💡 核心优势

| 方面               | 现有系统            | 策略模式           |
| ------------------ | ------------------- | ------------------ |
| **属性大小** | 所有法术共享40+字段 | 各类型独立5-10字段 |
| **扩展性**   | 需修改主类          | 只需新增策略       |
| **可测试性** | 耦合度高            | 独立测试各策略     |
| **可读性**   | switch-case很长     | 逻辑分散清晰       |

---

## 🎮 快速体验

### 在Unity中（如果想测试）

1. **查看现有系统：**

   - 打开 `Step4_SpellData.cs`
   - 看 `Execute()` 方法的 switch-case
   - 感受复杂度
2. **对比新系统：**

   - 打开 `04_新的SpellData.cs`
   - 看简洁的 `Execute()` 方法
   - 只有一行！
3. **理解差异：**

   - 现有系统：逻辑都在 SpellData 中
   - 新系统：逻辑在独立的策略类中

---

## ❓ 常见问题

### Q1: 我必须迁移吗？

**A:** 不必须！这只是示例。如果现有系统够用，继续用就好。

### Q2: 策略模式会影响性能吗？

**A:** 几乎不会。虚函数调用开销<1%，可忽略。

### Q3: 学习策略模式难吗？

**A:** 概念简单，但需要练习。建议先理解示例，再动手。

### Q4: 什么时候应该用策略模式？

**A:** 当你发现：

- SpellStats 超过20个字段
- 添加新类型很痛苦
- switch-case 超过5个分支

### Q5: 可以只迁移部分吗？

**A:** 可以！新旧系统可以共存。新功能用新系统，旧功能保持不变。

---

## 📖 延伸阅读

### 设计模式相关

- **策略模式详解：** Refactoring.Guru
- **Unity中的设计模式：** Unite 演讲
- **开闭原则：** SOLID原则

### 推荐顺序

1. 先理解问题（为什么需要策略模式）
2. 再看解决方案（如何实现）
3. 最后决定行动（要不要迁移）

---

## 🎯 下一步行动

### 如果你想继续学习：

- [X] 阅读本文档
- [ ] 按顺序阅读 6 个文件
- [ ] 对比现有系统
- [ ] 决定是否迁移

### 如果你想实践：

- [ ] 创建一个测试法术用新系统
- [ ] 对比新旧系统的使用体验
- [ ] 评估是否适合你的项目

### 如果你想深入：

- [ ] 学习更多设计模式
- [ ] 研究其他架构方案
- [ ] 分享经验

---

## 💬 反馈

这套示例对你有帮助吗？

- 清楚易懂 👍
- 有点难懂 🤔
- 需要更多例子 📖
- 其他建议 💡

随时告诉我！

---

**祝学习愉快！** 🚀

_记住：好的架构不是设计出来的，是演进出来的。_
